# 虚拟机类加载机制

以下博文中类型=类和接口

> Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制



在Java中，类型的加载，连续和初始化过程都是在`程序运行期间`完成的，这个特点可以为Java应用提供了极高的扩展性和灵活性，这也就是Java天生可以动态扩展和动态连接的原因（动态代理等）

> 例子：比如说编写一个接口类，我们可以在程序运行的时候，再指定该类实际的实现类，还有就是可以通过Java内置的或者自定义的类加载器，让某个本地的应用程序在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分。



因为最终都是把代码编译成class文件，这个class文件是`一串二进制字节流`，我们可以从硬盘文件，网络，数据库，内存或者动态产生中获得



## 类加载的时机

一个类型从被`加载`到虚拟机内存中开始，到`卸载`出内存为止，它的整个生命周期将会经历`加载(Loading),验证(Verification),准备(Preparation),解析(Resolution),初始化(Initialization),使用(Using),卸载(Unloading)`七个阶段，但是验证，准备，解析三个部分统称为`连接(Linking)`

![image-20220720222850253](https://picture.xcye.xyz/image-20220720222850253.png)



> 加载，验证，准备，初始化和卸载这五个阶段的顺序是不变的，也是确定的，类型的加载过程必须按照这个过程进行，对象才能被实例化或者加载
>
> 但是解析阶段在某些情况下，可以在初始化之后，也可以再初始化之前
>
> > 在初始化之后才进行解析是为了支持Java语言的`运行时绑定特性`（动态绑定或晚期绑定）



一个类型什么时候进行第一阶段的`加载`过程，并没有严格区分，由jvm的实现厂商来决定，但是对于初始化阶段，如果遇到以下6种情况，就必须立即对类进行初始化，初始化之前的4个必须的阶段也会进行

1. 遇到`new、getstatic、putstatic或invokestatic`这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java 代码场景有：

    - 使用new关键字实例化对象的时候。

    - 读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
    - 调用一个类型的静态方法的时候。

2. 使用`java.lang.reflect`包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。

3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。

5. 当使用 JDK 7 新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

6. 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

> `有且只有`上面这六种场景中的行为才会触发类的初始化过程，被称为`主动引用`，对于其他的，除了主动引用外，其他的引用都不会触发初始化，称为`被动引用`



对于`静态字段`，`只有直接定义该字段的类才会被初始化`，也就是如果在子类中，访问父类中的某个静态字段，只会触发父类的初始化而不会触发子类的初始化，比如下面这个

```java
class superClass {
    public static int a = 12;
}
class sub {
    static {
        System.out.print("subclass");
    }
}
class main {
    public static void main() {
      	sub.a;
    }
}
// 并不会打印subclass
```

