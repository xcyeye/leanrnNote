---
date: "2021/10/19 14:32"
description: "冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。因为冒泡排序的时间复杂度是一个平方阶，如果其中某一趟一次都没有排序(`数组已经是一个有序的了`)，那么就认为数组已经是有序，所以我们可以直接结束此排序过程"

---





# 冒泡排序

::: tip

`冒泡排序（Bubble Sorting）`的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,**依次比较相邻元素的值，若发现逆序则交换**，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

:::



## 案例

现在有一个数组

```java
int[] arr = {3,9,-1,10,-2};
```

那么其排序的过程为

::: details view

```java
第1趟排序
(1)[3, 9, -1, 10, -2]
(2)[3, -1, 9, 10, -2]
(3)[3, -1, 9, 10, -2]
(4)[3, -1, 9, -2, 10]

第2趟排序
(1)[-1, 3, 9, -2, 10]
(2)[-1, 3, 9, -2, 10]
(3)[-1, 3, -2, 9, 10]

第3趟排序
(1)[-1, 3, -2, 9, 10]
(2)[-1, -2, 3, 9, 10]

第4趟排序
(1)[-2, -1, 3, 9, 10]
```

:::



![image-20220709091946961](https://picture.xcye.xyz/image-20220709091946961.png)

## 代码实现

使用代码实现下面数组的冒泡排序

```java
int[] arr = {3,9,-1,10,-2};
```



::: tip

写代码的时候，需要注意

1. 冒泡排序第一趟的时候就已经确定最大值，随着趟数的增加，数组后面位置就已经排出序了
2. 冒泡排序总共需要执行的趟数为`arr.length -1`(不考虑冒泡排序优化的情况下)，所以冒泡排序的时间复杂度为`T(n) = n^2`，这里的n等于`arr.length -1`



冒泡排序优化的思路:

> 对冒泡排序进行优化的时候，可以从下面几方面进行考虑
>
> 1. 因为冒泡排序的时间复杂度是一个平方阶，如果其中某一趟一次都没有排序(`数组已经是一个有序的了`)，那么就认为数组已经是有序，所以我们可以直接结束此排序过程

:::



```java
public static void sort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int origin = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = origin;
            }
        }
    }
}
```



> 上面的代码使用一个没有经过优化的冒泡排序，每一趟其都会执行`arr.length - 1`次



运行结果

::: details view

```java
第1趟排序
(1)[3, 9, -1, 10, -2]
(2)[3, -1, 9, 10, -2]
(3)[3, -1, 9, 10, -2]
(4)[3, -1, 9, -2, 10]

第2趟排序
(1)[-1, 3, 9, -2, 10]
(2)[-1, 3, 9, -2, 10]
(3)[-1, 3, -2, 9, 10]
(4)[-1, 3, -2, 9, 10]

第3趟排序
(1)[-1, 3, -2, 9, 10]
(2)[-1, -2, 3, 9, 10]
(3)[-1, -2, 3, 9, 10]
(4)[-1, -2, 3, 9, 10]

第4趟排序
(1)[-2, -1, 3, 9, 10]
(2)[-2, -1, 3, 9, 10]
(3)[-2, -1, 3, 9, 10]
(4)[-2, -1, 3, 9, 10]
```



:::



### 经过优化

```java
public static void sort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        System.out.println("第" + (i + 1) + "趟排序");
        boolean flag = false;
        for (int j = 0; j < arr.length - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int origin = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = origin;

                flag = true;
            }
            System.out.printf("(" + (j + 1) + ")" + Arrays.toString(arr));
            System.out.println();
        }
        System.out.println();

        if (!flag) {
            //一次也进入到for循环中，则直接退出循环，因为数据已经是有效的了
            break;
        }
    }
}
```

> 优化的思想，就是考虑到某一趟，一次也没有进入到if语句中，那么这个数组已经是有序的话，那么就可以退出循环



## 测试

我使用下面的这个数组进行测试，发现执行几次的，排序时间平均为`22`秒左右

```java
long startTime = System.currentTimeMillis();
int[] randomArr = new int[100000];

for (int i = 0; i < randomArr.length; i++) {
    randomArr[i] = (int) (Math.random() * 100000);
}
sort(randomArr);
long endTime = System.currentTimeMillis();
System.out.println("排序时间: " + (endTime - startTime));
```



