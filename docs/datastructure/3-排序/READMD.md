---
date: '2021/10/18'
description: "排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。内部排序指将需要处理的所有数据都加到内部存储器中进行排序。外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序"
---



# 排序

排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

排序可以分为两类

- 内部排序:
  指将需要处理的所有数据都加载到内部存储器中进行排序。
- 外部排序法：
  数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。



内部排序可以分为8大类，分别是

- 插入排序
  - 直接插入排序
  - 希尔排序
- 选择排序
  - 简单选择排序
  - 堆排序
- 交换排序
  - 冒泡排序
  - 快速排序
- 归并排序
- 基数排序



::: details view

![](https://picture.xcye.xyz/image-20211018220557729.png?x-oss-process=style/pictureProcess1)

:::





## 时间复杂度

一个算法花费的时候和他执行的次数成正比，执行的次数多，所花费的时间就多

::: tip

一个算法中的语句执行次数称为语句频度或时间频度，记为`T(n)`

:::



比如下面的两个程序，他们执行的结果是一样的，但是他们的时间频度是完全不一样的

![](https://picture.xcye.xyz/image-20211018223626997.png?x-oss-process=style/pictureProcess1)

> 计算从1加到100，因为最终for循环会执行101此，所以时间频度`T(n) = 101`



![](https://picture.xcye.xyz/image-20211018223729486.png?x-oss-process=style/pictureProcess1)

> 这个的时间频度`T(n) = 1`，因为只需要执行一次，就可以得出最终结果

### 时间复杂度

#### 忽略常数项

> 1. 忽略常数项

![](https://picture.xcye.xyz/image-20211018225238212.png?x-oss-process=style/pictureProcess1)

::: tip

2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略
3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略

`如果有常数项的话，那么在计算时间复杂度的时候，我们可以忽略`

:::



> 2. 忽略低次项

![](https://picture.xcye.xyz/image-20211018230214316.png?x-oss-process=style/pictureProcess1)

::: tip

2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10
n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20



`这里的忽略低次项，是指通过+号链接的算式，如果是*，是不能被忽略的`

:::



> 3. 忽略系数

![](https://picture.xcye.xyz/image-20211018230443859.png?x-oss-process=style/pictureProcess1)

::: tip

随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。
而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键

:::





### 时间复杂度概述

一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用`T(n)`表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，`T(n) / f(n)` 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作`T(n)=Ｏ( f(n))`，称`Ｏ( f(n))`为算法的`渐进时间复杂度`，简称`时间复杂度`。

`T(n)`不同，但时间复杂度可能相同。 如：`T(n)=n²+7n+6`与`T(n)=3n²+2n+2`它们的T(n) 不同，但时间复杂度相同，都为O(n²)。

> 因为这里忽略系数和常数项，低次项，所以他们最终都为`T(n) =n^2 `

#### 计算时间复杂度的方法

::: tip

- 用常数1代替运行时间中的所有加法常数  

  >  T(n)=n²+7n+6  => T(n)=n²+7n+1

- 修改后的运行次数函数中，只保留最高阶项  

  >  T(n)=n²+7n+1 => T(n) = n²

- 去除最高阶项的系数

  >  T(n) = n² => T(n) = n² => O(n²)

:::



#### 常见的时间复杂度

##### 常数阶O(1)

> 无论代码执行了多少行，只要是`没有循环等复杂结构`，那这个代码的时间复杂度就都是O(1)

::: details view

```java
int i = 1;
int j = 2;
++ i;
j++;
int m = i + j;
```



:::

> 无论代码有多长，只要他们中没有循环等操作，尽管代码有几十万行，那么他们的时间复杂度最终也是`O(1)`



##### 对数阶O(log2n)

::: details view

```java
int i = 1;
while(i < n) {
	i = i * 2;
}
```

:::

在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。

假设循环x次之后，i就大于2了，此时这个循环就退出了，也就是说 2 的x次方等于n，那么 `x = log2n`也就是说当循环`log2n`次以后，这个代码就结束了。因此这个代码的时间复杂度为：`O(log2n)` 。`O(log2n)`的这个2 时间上是根据代码变化的，`i = i * 3` ，则是`O(log3n)`

> 计算此类时间复杂度的时候，log函数的底数可以看做是 `* n`的n值

![](https://picture.xcye.xyz/image-20211019085109841.png?x-oss-process=style/pictureProcess1)









##### 线性阶O(n)

::: details view

```java
for(i = 1;i <= n; ++i) {
    j = i;
    j++;
}
```

:::



> 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用`O(n)`来表示它的时间复杂度

##### 线性对数阶O(nlog2n)

::: details view

```java
for(m = 1;m < n; m++) {
    i = 1;
    while(i < n) {
        i = i * 2;
    }
}
```



:::



> 线性对数阶`O(nlog2n)`其实非常容易理解，将时间复杂度为`O(log2n)`的代码循环n遍的话，那么它的时间复杂度就是 `n * O(log2n)`，也就是了`O(nlog2n)`
>
> 因为while循环里面是一个对数阶
>
> for循环是一个线性阶，他们相乘也就是一个线性对数阶



##### 平方阶O(n^2)

::: details view

```java
for(x = 1;i <= n; x++) {
    for(i = 1;i<= n;i++) {
        j = i;
        j++l
    }
}
```



:::



> 平方阶`O(n²)` 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n)
>
> `如果全部都是一个for循环的嵌套的话，有几层for循环，那么就把for循环的跳出条件相乘，就可以了`







##### 立方阶O(n^3)

> 参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似

##### k次方阶O(n^k)

> 参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似

##### 指数阶O(2^n)



他们之间的图关系为

![](https://picture.xcye.xyz/image-20211019084036464.png?x-oss-process=style/pictureProcess1)

##### 总结

::: tip

常见的算法时间复杂度由小到大依次为：

>  Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) 

随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
`应该尽可能避免使用指数阶的算法`

:::



### 平均时间复杂度和最坏时间复杂度

1. 平均时间复杂度

   > 指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
   
2. 最坏情况下的时间复杂度称最坏时间复杂度

   >  **一般讨论的时间复杂度均是最坏情况下的时间复杂度**。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长

::: tip

`平均时间复杂度和最坏时间复杂度是否一致，和算法有关`

:::



![](https://picture.xcye.xyz/image-20211019130244872.png)



## 算法的空间复杂度

- 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。 

- 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和**归并排序算法**,**基数排序**就属于这种情况 

- 在做算法分析时，主要讨论的是时间复杂度。**从用户使用体验上看**，**更看重的程序执行的速度**。一些缓存产品(redis, memcache)和算法(基数排序)**本质就是用空间换时间**.

