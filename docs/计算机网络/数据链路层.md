# 数据链路层 

![image-20220629152704678](https://picture.xcye.xyz/image-20220629152704678.png)

对于上图来说，主机都包含TCP/IP协议中的各个层次，而路由器只需要拥有`网络层，数据链路层，物理层`便可以了

上图中，主机和路由器之间通过传输媒体相连接，当主机H1发送数据到主机H2的过程中，主机H1对消息进行逐层封装成帧，然后通过传输媒体传输到路由器，路由器由下往上逐层解封到网络层，路由器根据数据包的目的网络地址和自身转发表，确定数据包的转发端口，然后又从网络层向下逐层封装数据包，并通过物理层将数据包发送到传输媒体，数据包达到主机H2时，也是需要由下往上逐层解封



在学数据链路层相关的东西的时候，我们可以只关心数据链路层的相关知识，可以不用考虑物理层等其他层次，所以可以把数据包看作只在数据链路层从左向右沿水平方向传送，比如上图中，主机H1到H2的通信，可以看作在4段不同链路上的通信组成的

![image-20220629162014521](https://picture.xcye.xyz/image-20220629162014521.png)

> 链路(Link)：就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点
>
> 数据链路(Data Link)：把实现通信协议的硬件和软件加到链路上，就构成了数据链路

在数据链路上传输的数据包，又称为帧，也就是说，`数据链路层以帧为单位传输和处理数据`



在数据链路层中，需要解决的三个重要问题

1. 封装成帧
2. 差错检测
3. 可靠传输



## 三个重要问题

### 封装成帧

![image-20220629162436090](https://picture.xcye.xyz/image-20220629162436090.png)

在上图的链路中，两台主机都需要对发送和接收的数据包进行5个层次的封装和解封

1. 发送方通过应用层对发送的数据封装成应用层协议数据单元，然后交付给运输层

2. 运输层对其添加运输层协议首部，使之成为运输层协议数据单元，然后交付给网络层

    ![image-20220629162743225](https://picture.xcye.xyz/image-20220629162743225.png)

3. 网络层对其添加网络层协议首部，使之成为网络层协议数据单元，然后交付给数据链路层

    ![image-20220629162848501](https://picture.xcye.xyz/image-20220629162848501.png)
    
4. 数据链路层给网络层协议数据单元添加一个数据链路层协议首部(简称为帧头)还要给其添加一个帧尾

    将数据链路层给网络层交付的协议数据单元添加帧头和帧尾的操作称为`封装成帧`

    ![image-20220629163227763](https://picture.xcye.xyz/image-20220629163227763.png)

    > 添加帧头和帧尾的目的都是为了在链路上以帧为单位传送数据，都是为了实现数据链路层本身的功能

比如以太网2的Mac格式

![image-20220629163550184](https://picture.xcye.xyz/image-20220629163550184.png)



### 差错检测

发送方将封装好的帧通过物理层发送到传输媒体，帧在传输过程中遭遇干扰后可能出现误码(如比特1变成比特0，反之)

![image-20220629163740487](https://picture.xcye.xyz/image-20220629163740487.png)

- 那么接收方主机如何判断在传输过程中是否出现了误码？

    判断是否出现误码，可以通过检错码来发现

    在发送之前，会基于待发送的数据和检错算法计算出检错码，并将其封装在帧尾

    ![image-20220629164025051](https://picture.xcye.xyz/image-20220629164025051.png)

    > 在以太网2的Mac中，帧尾就是4字节的帧检验序列`FCS字段`，要写入该字段的内容，就是检错码
    >
    > ![image-20220629164212793](https://picture.xcye.xyz/image-20220629164212793.png)

    接收方主机收到帧后，通过检错码和检错算法，就可以判断出帧在传输过程中是否出现误码

    ![image-20220629164523586](https://picture.xcye.xyz/image-20220629164523586.png)



### 可靠传输

接收方主机收到有误码的帧后，不会接受该帧，会将其丢弃，如果数据链路层向上层提供的是不可靠传输服务，那么丢失之后，不会再有其他的措施，但是如果提供的是可靠传输服务，会有其他措施来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本



> 因为误码是不能完全避免的，但若能实现发送方发送什么，接收方就能收到什么，就称为`可靠传输`

> `以上三个问题的举例都是使用点对点信道的数据链路层来举例`，对于使用广播信道的数据链路层，还会有其他的问题



### 广播信道问题

![image-20220629165123083](https://picture.xcye.xyz/image-20220629165123083.png)

主机A向主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，在传输的过程中，会将帧的目的地址添加在帧中一起传输，这样主机BDE就能知道这些数据不是发给自己的，主机C知道是发给自己的

 在以太网2的Mac中，首部的三个字段中，有两个字段都是和地址相关，一个是目的地址字段，另一个是源地址字段

![image-20220629165555847](https://picture.xcye.xyz/image-20220629165555847.png)



当总线上多台主机同时使用总线来传输帧时，传输信号就会产生碰撞，这个采用`广播信道的共享局域网`不可避免的

![image-20220629165613714](https://picture.xcye.xyz/image-20220629165613714.png)

以太网采用的方式是，使用一种特殊的协议`CSMA/CD`(载波监听多点接入/碰撞检测)



但是现在使用`点对点链路和链路层交换机`的交换式局域网在有线(局域网)领域已完全取代了共享式局域网

![image-20220629170418185](https://picture.xcye.xyz/image-20220629170418185.png)



但是无线局域网仍然使用的是共享信道技术

![image-20220629170532076](https://picture.xcye.xyz/image-20220629170532076.png)



## 封装成帧

> 对数据链路层上层交付的协议数据单元添加帧头和帧尾使之成为帧的操作



![image-20220629170844731](https://picture.xcye.xyz/image-20220629170844731.png)



当数据链路层对上层交付的协议数据单元封装成帧后，还会通过物理层，将构成帧的各比特转换成发送信号发送到传输媒体

![image-20220629171038090](https://picture.xcye.xyz/image-20220629171038090.png)

![image-20220629171059418](https://picture.xcye.xyz/image-20220629171059418.png)



### 判断传输媒体中的某段比特是否为帧

![image-20220629171206080](https://picture.xcye.xyz/image-20220629171206080.png)

> 帧头和帧尾的作用之一就是帧定界



例如在PPP帧的格式中

![image-20220629171307682](https://picture.xcye.xyz/image-20220629171307682.png)

> 第一个字节的标志就是一个`帧定界`



假设发送方发送的是PPP帧，下图红色标注的部分就是一个个帧定界，那么接收方的数据链路层就可以根据帧定界标志

![image-20220629171356018](https://picture.xcye.xyz/image-20220629171356018.png)

从物理层交付的比特流中提取出一个个帧

![image-20220629171539524](https://picture.xcye.xyz/image-20220629171539524.png)

> 并不是每一种数据链路层协议的帧都包含有帧定界标志,在以太网2的Mac格式帧中的帧头和帧尾中就没有包含帧定界标志



对于以太网2的Mac格式的帧，当数据链路层封装好Mac帧后，物理层会在Mac帧前面添加8字节的前导码，然后再将比特流转换成电信号发送

![image-20220629171923773](https://picture.xcye.xyz/image-20220629171923773.png)

前导码中的前7个字节为`前同步码`，作用是使接收方的时钟同步，之后的一个字节为帧的开始定界符，表明其后紧跟着的就是Mac帧

![image-20220629172013175](https://picture.xcye.xyz/image-20220629172013175.png)



以太网还规定帧间间隔时间为96比特的发送时间，因此Mac帧并不需要帧结束定界符

![image-20220629172240922](https://picture.xcye.xyz/image-20220629172240922.png)

### 透明传输

> 数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在



![image-20220629173516106](https://picture.xcye.xyz/image-20220629173516106.png)

比如上图，当数据链路层对上层传递的数据添加帧头和帧尾后(这里只添加帧头和帧尾帧定界标志，通常是一个特殊的数值)，但是如果在上层交付的协议数据单元中也包含了和帧定界标志的特殊符号，那么接收方就不能正确的接收该帧

![image-20220629174015821](https://picture.xcye.xyz/image-20220629174015821.png)

- 接收方处理帧的过程如下

    1. 当接收方收到第一个帧定界标识的时候，会认为这个是帧的开始(没错)

        ![image-20220629174304834](https://picture.xcye.xyz/image-20220629174304834.png)
	    
    2. 如果接收方又收到了一个和帧定界标识相同的特殊符号，那么会认为这是帧结束了
       
       ![image-20220629174442492](https://picture.xcye.xyz/image-20220629174442492.png)
       
       如果数据链路层不采取其他措施，来避免接收方对帧是否结束的误判，就不能称为透明传输，所以数据链路层对上层交付的协议数据单元有限制，其内容不能包含帧定界符，如果是这样的话，那么这样的数据链路层没有什么使用价值
       
       为了解决这个问题，各种数据链路层协议在发送帧之前，对帧的数据部分进行扫描，每出现一个帧定界符，就在其前面插入一个转义字符
       
       ![image-20220629174925951](https://picture.xcye.xyz/image-20220629174925951.png)
       
       接收方数据链路层在物理层交付的比特流中提取帧，遇到的第一个帧会认为是帧的开始，当遇到转义字符时，就知道其后面的1字节内容虽然和帧定界符相同，但是他是数据，而不是帧定界符，就避免了上面所遇到的问题
       
       > 转义字符时一种特殊的控制字符，其长度为1字节，十进制值为27，而并不是`E,S,C`这三个字符
       
       
       
       > 上面是面向字节的物理链路，是使用字节填充(或字符填充)的方法来实现透明传输，对于面向比特的链路，应该使用比特填充的方法来实现透明传输
       
       
       
       ![image-20220629204626129](https://picture.xcye.xyz/image-20220629204626129.png)
       
       在发送之前，可以采用`零比特填充法`，对数据部分进行扫描，每5个连续的比特1后面就插入1个比特0，这样就可以确保帧定界在整个帧中的唯一性，从而实现透明传输，接收方接收数据时，将帧的数据部分的每5个连续的比特1后面的那个比特0剔除即可  
       
       ![image-20220629205150659](https://picture.xcye.xyz/image-20220629205150659.png)
       
       > 为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些 
       
       ![image-20220629205348026](https://picture.xcye.xyz/image-20220629205348026.png)
       
       像上图这样，应该使帧的数据部分长度大于帧头和帧尾，这样才能提高帧的传输效率
       
       > 考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即`最大传送单元MTU`
       
       
       
       
       
       ![image-20220629205606602](https://picture.xcye.xyz/image-20220629205606602.png)
       
       
       
       
       
       
       
       
       

## 差错检测

 比特差错：实际的通信链路都不是理想的，比特在传输过程中可能产生差错，1可能会变成0,0也可能变成1

在一段时间内，传输错误的比特占所传输比特总数的比率称为`误码率RER`

![image-20220629205906418](https://picture.xcye.xyz/image-20220629205906418.png)

> 使用`差错检测码`来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一



![image-20220629210059223](https://picture.xcye.xyz/image-20220629210059223.png)

> 以太网2的Mac格式的帧的尾部字段中包含了一个长度为4字节的帧检验序列FCS字段
>
> 在点对点协议的PPP帧格式的帧的尾部也包含了一个长度为2字节的帧检验序列FCS字段





### 常用检测方法

#### 奇偶校验

在待发送的数据后面添加1位奇偶校验位，使整个数据(包括所添加的校验位在内)中“1”的个数为奇数（奇校验）或偶数（偶校验）



![image-20220629210803317](https://picture.xcye.xyz/image-20220629210803317.png)

其执行的过程如下

1. 在发送数据之前，收发主机双方约定使用奇校验，发送方在待发送的数据后面添加1位1，使数据中1的个数为奇数个，如果在传输数据的过程中发生了一次误码，那么可能1的个数变成了偶数个，就可以知道传输过程中发生了误码

    如果在传输过程中，发生了两个比特位的数据改变，那么这种是不改变数据中1的奇偶性的

2. 对于偶校验，方法和奇校验是一样的

因为这种检测方法存在缺陷，所以一般都不会使用





#### 循环冗余校验CRC(Cyclic Redundancy Check)

这是一种具有很强检错能力的检错方法，漏检率极低

1. 收发双方约定好一个生成多项式G(X)
2. 发送方基于待发送的数据和生成多项式计算出差错检测码(冗余码)，将其添加到待传输数据的后面一起传输
3. 接收方通过生成多项式来计算收到的数据是否产生了误码

![image-20220629212717906](https://picture.xcye.xyz/image-20220629212717906.png)

![image-20220629212830936](https://picture.xcye.xyz/image-20220629212830936.png)





- `检错码`只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此`无法纠正错误`。
- 要想纠正传输中的差错，可以使用冗余信息更多的纠错码进;行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。
- 循环冗余校验CRC有很好的检错能力（漏检率非常低》，虽然计算比较复杂，但非常易手用硬件实现，因此被广泛应用于数据链路层。
- 在计算机网络中通常采用我们后续课程中将要讨论的检错重传方式求纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取次子数据链路层向其上层提供的是可靠传前服务还是不可靠传输服务。





## 可靠传输

因为在传输媒体中传输会发生误码，所以如果存在误码，都会有哪些操作？

> 因为这个过程是发生在接收端，接收端需要对接收到的数据进行一层层的解封，所以对于发生误码的数据的处理，主要是看数据链路层向上层提供的服务类型

- 如果数据链路层向上层提供的服务类型为不可靠传输服务，那么他只会丢弃有误码的帧，其他的什么也不做

- 如果数据链路层向上层提供的服务类型为可靠传输服务，那么会想办法实现发送端发送什么，接收端就收到什么

    ![image-20220629214349415](https://picture.xcye.xyz/image-20220629214349415.png)

    接收端会返回一条消息告诉发送端，刚才发送的帧产生了误码，请重发，发送方收到消息后，会重发之前产生误码的那个帧即可

    ![image-20220629214515255](https://picture.xcye.xyz/image-20220629214515255.png)

    > 但是这种是不安全的，如果通知发送方重发消息的这个帧，也发生了误码，那又会怎么样

    

    

    

一般情况下，有线链路的误码率比较低，为了减少开销，并不要求数据链路层向上层提供可靠传输服务，即使出现了误码，可靠传输的问题由其上层处理

对与无线链路，因为容易收到干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务

![image-20220629214908472](https://picture.xcye.xyz/image-20220629214908472.png)







比特差错只是传输差错中的一种，从整个计算机网络体系结构来看，传输差错还包括`分组丢失，分组失序，分组重复`，这三个一般不会出现在数据链路层，而会出现在其上层。

可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输

![image-20220629215839182](https://picture.xcye.xyz/image-20220629215839182.png)



### 分组失序

![image-20220629215353307](https://picture.xcye.xyz/image-20220629215353307.png)

![image-20220629215417391](https://picture.xcye.xyz/image-20220629215417391.png)

> 发送时的顺序和接收时的顺序不同



### 分组重复

![image-20220629215512178](https://picture.xcye.xyz/image-20220629215512178.png)

主机H6给主机H2发送数据时，因为某些原因，导致消息一直停留在R2，主机H6因为超时，重新发送了一条数据，但是经过一段时间后，滞留在R2处的消息又继续发送到主机H2，从而导致消息重复

![image-20220629215707930](https://picture.xcye.xyz/image-20220629215707930.png)



## 可靠传输的实现机制

> 停止-等待协议SW，回退N帧协议GBN，选择重传协议SR实现机制的基本原理并不局限于数据链路层，可以应用到计算机网络体系结构的各层次协议中



### 停止-等待协议SW

- 发送方给接收方发送数据分组，接收方收到后对其进行差错检测，若没有误码，则接收该分组，并给发送方发送确认分组，简称`ACK`，发送方收到对所发送分组的确认分组后，才能发送下一条分组，如果在传输过程中，发生了误码，接收方收到后，对其进行差错检测，发现了误码，则丢弃该数据分组，并给发送方发送否认分组，简称`NAK`，发送方收到对所发送数据分组的否认分组后，就知道之前发送的数据分组发生了误码，被接收方拒绝，于是立刻重传该数据分组，因此，发送方每发送一条数据分组后，并不能立刻将数据分组从缓存中删除，只有收到针对该数据分组的确认分组后，才能将其从缓存中删除

    > 发送方每发送完一个分组后，就停止发送下一个数据分组，等待来自接收方的确认分组或者否认分组，若收到确认分组，则可继续发送下一条数据分组，若收到否认分组，则重发之前发送的那个数据分组，这样就实现了发送方发送什么，接收方就收到什么

    ![image-20220630090755389](https://picture.xcye.xyz/image-20220630090755389.png)

- 发送方给接收方发送数据分组，但是该数据分组在传输过程中丢失了(对于数据链路层点对点信道而言，不太容易出现这种情况，但对于通过路由器互连的互联网而言，这种情况很容易发生)

    > 接收方收不到数据分组，就不会发送ACK或NAK。如果不采取其他措施，发送方就会一直处于等待接收方ACK或NAK的状态。
    > 为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间，而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，这就叫做`超时重传`。
    > 一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”

    当发生超时重传后，接收方收到数据分组，给接收方发送ACK或者NAK，则发送方继续发送下一个分组

    ![image-20220630091326516](https://picture.xcye.xyz/image-20220630091326516.png)

- 发送方给接收方发送数据分组，接收方接收后，在向发送方发送确认分组，但是该确认分组在传输过程中丢失了，这样会导致发送方对之前所发送的数据分组的超时重传，如果该重传的数据分组也正确到达了接收方，那么接收方如何判断接收到的数据分组是否是一个重复的分组？

    > 为避免分组重复这种传输错误，必须给每个分组带上序号。
    > 对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分
    > 组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就够了，即比特0和1，接收方就可以判断出该数据分组是否是重复的
    >
    > > 因为对于停止-等待协议来说，只有收到确认分组后，才能发送下一条数据分组

    接收方丢弃重复的分组，并给发送方发送针对该数据分组的确认分组，以免发送方对该数据分组的再次超时重传，发送方收到针对0号数据分组的确认分组后，就可以发送下一个数据分组，其序号为1，接收方正确收到1号分组后，给发送方发送确认分组

    ![image-20220630092155282](https://picture.xcye.xyz/image-20220630092155282.png)

- 发送方发送0号分组，接收方正确接收后给发送方发送确认分组，如果由于某些原因，确认分组迟到了，便会导致发送方对0号数据分组的超时重传，在重传的0号数据分组的传输过程中，发送方收到了迟到的确认分组，于是发送1号数据分组，接收方收到重传的0号数据分组后，发现这是一个重复的数据分组，将其丢弃，并针对该数据分组发送一个确认分组，以免发送方再次超时重传该数据分组

    ![image-20220630101927392](https://picture.xcye.xyz/image-20220630101927392.png)

    在上图中，接收方发回的两个确认分组都是针对于0号数据分组的，那么发送方如何确认这两个确认分组都是来自于0号数据分组？针对这个问题，可以对确认分组也进行编号，可以避免这个问题

    ![image-20220630102150646](https://picture.xcye.xyz/image-20220630102150646.png)

    发送方收到两个相同的0号的确认分组后，对第二个确认分组，忽略就可以了

    ![image-20220630110813359](https://picture.xcye.xyz/image-20220630110813359.png)

    > 上图箭头所指的DATA0和最开始的DATA0不是同一个数据分组
    >
    > > 对于数据链路层的点对点信道，往返时间比较固定，不会出现确认迟到情况，因此，如果只在数据链路层实现停止-等待协议，可以不用给确认分组编号，但是对于误码率较高的点对点链路，为使发送方今早重传，也可给发送方发送否认分组



#### 停止-等待协议的信道利用率

  ![](https://picture.xcye.xyz/image-20220630112417452.png)

各时间段的含义(忽略接收方对数据分组的处理时延以及发送方确认分组的处理时延)：

1. Td：发送方发送数据分组所耗费的发送时延
2. RTT：是收发双方之间的往返时间 
3. Ta：接收方发送确认分组所耗费的发送时延
4. Td+RTT+Ta：发送方从发送一个数据分组开始，到可以发送下一个数据分组所经历的总时间

![image-20220630112925793](https://picture.xcye.xyz/image-20220630112925793.png)



> 当往返时延RTT远大于数据帧发送时延Td时(例如使用卫星链路)，信道利用率非常低，若出现重传，则对于传送有用的数据信息来说，信道利用率更低，所以为了解决使用停止-等待协议所带来的信道利用率低的缺点，就可以使用另外两种协议：后退N帧协议GBN和选择重传协议SR

![image-20220630113310631](https://picture.xcye.xyz/image-20220630113310631.png)

### 回退N帧协议GBN

如果使用停止-等待协议发送数据分组，发送方只有在收到确认分组后，才能发送下一个数据分组，所以信道利用率很低

![image-20220630113604616](https://picture.xcye.xyz/image-20220630113604616.png)

如果在发送完一个数据分组后，又继续发送几个数据分组，那么便可以提高信道的利用率



> 采用3个比特给分组编序号，为何序号是0~7？
>
> 一个比特只有两个数字，即0和1，所以有三个比特，那么就有2^3个组合，即000,001,010,011,100,101,110,111，这8个二进制转换成十进制就是0~7



![image-20220630115557436](https://picture.xcye.xyz/image-20220630115557436.png)

上图所示的是收发双方的分组序号，当序号增加到7时，又会从0开始，发送方需要维持一个发送窗口，序号落在发送窗口内的数据分组可被连续发送，而不必等收到接收方的相应确认分组后再发送，可将发送窗口的尺寸计为WT，对于上图的采用3个比特给分组编号情况，WT的取值为[1,2^3-1]，本次对WT取值为5

> 如果WT的取值为1，那么就相当于停止-等待协议，就是一次只能发送一个，收到确认分组后，才能继续发送，如果WT的值超过取值范围的上限，会造成严重的错误



![image-20220630120143127](https://picture.xcye.xyz/image-20220630120143127.png)

上图中，数据落在发送窗口内的数据分组，可以发送，而没有落在数据窗口内的数据分组，不能发送

接收窗口的尺寸记作WR，对于N帧回退协议，`其取值只能为1`，和停止-等待协议是相同的

![image-20220630120340029](https://picture.xcye.xyz/image-20220630120340029.png)

上图，数据落在接收窗口内的数据，可以被接收，落在接收窗口之外的数据，不能被接收



- 对于在传输过程中，没有出现差错的情况

    ![image-20220630132526517](https://picture.xcye.xyz/image-20220630132526517.png)

    发送方将数据依次发送出去，在传输过程中假如没有出现误码，乱序等情况，接收方按序接收他们，接收方每接收一个，接收窗口就向右滑动一个位置(最开始接收窗口在0的位置)，并给发送方发送针对该接收分组的确认分组(0~4浩确认分组)

    ![image-20220630132719562](https://picture.xcye.xyz/image-20220630132719562.png)

    0~4号确认分组经过互联网的传输正确到达了发送方

    ![image-20220630132858788](https://picture.xcye.xyz/image-20220630132858788.png)

    发送方每接收一个，发送窗口就向前(右)滑动一个位置

    ![image-20220630132944316](https://picture.xcye.xyz/image-20220630132944316.png)

    这样就有新的序号落入发送窗口，这样发送方就可以将收到确认分组的数据分组从缓存中删除

    ![image-20220630133056693](https://picture.xcye.xyz/image-20220630133056693.png)

    接收方可以择机将接收的数据分组交付给上层处理

    ![image-20220630133140230](https://picture.xcye.xyz/image-20220630133140230.png)

#### 累积确认

对于回退N帧协议，可以采用累积确认的方式，接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认，ACKn表示序号为n及以前的所有数据分组都已正确接收了

![](https://picture.xcye.xyz/image-20220630133649324.png)

发送方将序号落在发送窗口内的0~4号数据分组依次连续发送出去，并经过互联网的传输，正确到达接收方

![image-20220630134022800](https://picture.xcye.xyz/image-20220630134022800.png)

接收方依次接收他们，当接收方接收了0号和1号只有，给发送方发送了一个累积确认ACK1

![image-20220630134057341](https://picture.xcye.xyz/image-20220630134057341.png)

当接收完2~4号数据分组后，又给发送方发送了一个累积确认ACK4

![image-20220630134216786](https://picture.xcye.xyz/image-20220630134216786.png)

假设ACK1在传输过程中丢失了

![image-20220630134756849](https://picture.xcye.xyz/image-20220630134756849.png)

而ACK4正确到达发送方

![image-20220630134827043](https://picture.xcye.xyz/image-20220630134827043.png)

发送便知道，序号为4及之前的数据分组已被接收方正确接收了，然后会将发送窗口向前(右)滑动5个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除，接收方可以择机将已接收的数据交付上层处理

![image-20220630135004902](https://picture.xcye.xyz/image-20220630135004902.png)

![image-20220630135126033](https://picture.xcye.xyz/image-20220630135126033.png)



> 使用累积确认的好处？
>
> 如上这样，当ACK1丢失了，ACK4正确接收，也不会导致数据分组0和1重传，还可以减少接收方的开销，减少对网络资源的占用
>
> 但是累积确认也存在缺点，不能及时向发送方反映出接收方已经正确接收的数据分组信息



- 对于出现差错的情况

    1. 发送方将序号落在发送窗口内的这5个数据分组发送给接收方，并假设传输过程中发生了误码

        ![image-20220630135530576](https://picture.xcye.xyz/image-20220630135530576.png)

        接收方通过数据分组中的检错码发现了错误，于是丢弃该数据分组，而后续到达的这4个数据分组的序号和接收窗口中的需要不匹配，接收方同样也不能接受他们，将他们丢弃

        ![image-20220630135747905](https://picture.xcye.xyz/image-20220630135747905.png)

        并对之前按需接收的最后一个分组进行确认(因为5已经丢弃了，所以这里得最后一个分组是4)，也就是发送ACK4，每丢弃一个分组，就发送一个ACK4

        ![image-20220630135933430](https://picture.xcye.xyz/image-20220630135933430.png)

        这4个ACK4经传输到达发送方，发送方之前就接收过ACK4，当收到这些ACK4时，就知道了之前发送的数据分组出现了差错，可以不等超时计时器超时就立刻开始重传，至于收到几个重复确认就立刻重传，由具体实现来决定

        ![image-20220630140208278](https://picture.xcye.xyz/image-20220630140208278.png)

        如果收到这4个重复的确认并不会触发发送方立刻重传，一段时间后，超时计时器出现超时，发送方将发送窗口内已发送过的这些数据分组全部重传

        ![image-20220630140532317](https://picture.xcye.xyz/image-20220630140532317.png)

        在这次过程中，尽管序号为6,7,0,1的数据分组正确到达接收方，但由于5号数据分组误码不能被接受，他们也“受到牵连”而不被接受，发送方还要重传这些数据分组，这就是所谓的`Go back N`(回退N帧)

           	 

        

    #### 发送窗口的取值大于最大值

    采用3个比特给数据分组编号，WT的最大值为7，这里故意取值为8

    ![image-20220630141327232](https://picture.xcye.xyz/image-20220630141327232.png)

    

    发送方将需要落在发送窗口内的0~7号这8个数据分组，依次连续发送出去，他们经过互联网的传输，正确到达了接收方

    ![image-20220630141445585](https://picture.xcye.xyz/image-20220630141445585.png)

    

    接收方按序正确接收他们后，给发送方发回累积确认ACK7

    ![image-20220630141536007](https://picture.xcye.xyz/image-20220630141536007.png)

    

    假设ACK7在传输过程中丢失，就会导致发送方的超时重传

    ![image-20220630141619561](https://picture.xcye.xyz/image-20220630141619561.png)

    重传的0~7号数据分组到达接收方

    ![image-20220630141645605](https://picture.xcye.xyz/image-20220630141645605.png)

    现在接收方根据接收窗口内的序号，对这8个数据分组按序接收，因为接收方已经接收过着8个数据分组了，现在是在重复接收

    ![image-20220630141757212](https://picture.xcye.xyz/image-20220630141757212.png)

    接收方无法分辨新旧数据分组

    ![image-20220630141829677](https://picture.xcye.xyz/image-20220630141829677.png)

    就会产生分组重复这种传输差错，所以规定发送窗口的尺寸不能超过其上限

    

    

    

#### 总结

![image-20220630151417376](https://picture.xcye.xyz/image-20220630151417376.png)

![image-20220630151612291](https://picture.xcye.xyz/image-20220630151612291.png)

### 选择重传协议SR

 回退N帧斜体的接收窗口尺寸`Wr只能等于1`，因此接收方只能按序接收正确到达的数据分组，一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃(尽管他们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费



> 为了进一步提高性能，可设法只重传出现误码的数据分组，因此，接收窗口的尺寸`Wr不应再等于1，而应该大于1，以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组`，等到所缺分组收齐后，再一并送交上层，这就是`选择重传协议`
>
> > `选择重传协议`为了使发送方仅重传出现差错的分组，接收方`不能再采用累积确认`，而需要对每个正确接收到的数据分组进行`逐一确认`





#### 过程解析

- 采用3个比特给分组编号，即序号为0~7
- 发送窗口的尺寸Wr的取值：[1,2^3-1]



![image-20220630153803490](https://picture.xcye.xyz/image-20220630153803490.png)

这次发送窗口的尺寸和接收窗口的尺寸都取4

![image-20220630153902390](https://picture.xcye.xyz/image-20220630153902390.png)



1. 发送方将序号落在发送窗口内的4个数据分组依次连续发送出去

    ![image-20220630153943293](https://picture.xcye.xyz/image-20220630153943293.png)

    如果其中的2号数据分组丢失了(只要序号落入接收窗口内且无误码的数据分组，接收方都会接收)

    ![image-20220630220825902](https://picture.xcye.xyz/image-20220630220825902.png)

    接收方接收0号和1号数据分组，并发送0号和1号确认分组，接收窗口向前滑动两个位置，这样就有4和5两个新的序号落入接收窗口

    ![image-20220630221025676](https://picture.xcye.xyz/image-20220630221025676.png)

    接收方接收3号数据分组，并发送3号确认分组，但是接收窗口不能向前滑动，因为3号数据分组是未按序到达的数据分组

    ![image-20220630221153629](https://picture.xcye.xyz/image-20220630221153629.png)

    这些确认分组到达发送方

    ![image-20220630221227055](https://picture.xcye.xyz/image-20220630221227055.png)

    发送方接收0号和1号确认分组，发送窗口向前滑动两个位置，这样就有4和5两个序号落入发送窗口

    ![image-20220630221329877](https://picture.xcye.xyz/image-20220630221329877.png)

    发送方将序号落入发送窗口的4号和5号数据分组发送出去

    ![image-20220630221457069](https://picture.xcye.xyz/image-20220630221457069.png)

    发送方可以将序号1和序号0对应的数据分组从缓存中删除，接收方可择机将已接收的0号和1号数据分组交付上层处理

    发送方接收3号数据分组，但是发送窗口不能向前滑动，因为还没有收到2号的确认分组，但是需要记录3号数据分组已收到确认，这样该数据分组就不会超时重发

    ![image-20220630221751648](https://picture.xcye.xyz/image-20220630221751648.png)

    4号和5号数据分组到达接收方

    ![image-20220630221822482](https://picture.xcye.xyz/image-20220630221822482.png)

    接收方接收他们，并发送4号和5号确认分组，但是接收窗口不能向前滑动，因为他们是未按序到达的数据分组

    ![image-20220630221904024](https://picture.xcye.xyz/image-20220630221904024.png)

    假设在4号和5号确认分组的传输过程中，发送方针对2号数据分组的重传计数器超时了，发送方重传2号数据分组，4号和5号确认分组陆续到达发送方，发送方接收他们，但是发送窗口不能向前移动(因为他们是未按序到达的数据分组)

    ![image-20220630222108507](https://picture.xcye.xyz/image-20220630222108507.png)

    发送方还未收到他们之前的2号确认分组，但是需要记录4号和5号数据分组已收到确认

    ![image-20220630222254164](https://picture.xcye.xyz/image-20220630222254164.png)

    这样就不会超时重发，发送方之前重传的2号数据分组到达接收方，接收方接收该数据分组，并发送2号确认分组

    ![image-20220630222353602](https://picture.xcye.xyz/image-20220630222353602.png)

    接收窗口现在可以向前滑动4个位置

    ![image-20220630222426605](https://picture.xcye.xyz/image-20220630222426605.png)

    这样就有6,7,0,1这4个新的序号落入接收窗口，2号数据分组经过互联网传输到达发送方，发送方接收2号确认分组，现在发送窗口可以向前滑动4个位置

    ![image-20220630222544928](https://picture.xcye.xyz/image-20220630222544928.png)

    发送方现在就可以继续将这4个序号(6,7,0,1)的数据分组依次发送出去

    



#### 发送/接收窗口尺寸问题

- 发送方的发送窗口尺寸Wt必须满足[1,2^(n-1)]，其中n是构成分组序号的比特数量 

    > 如果Wt=1，和停止-等待协议一样
    >
    > 如果Wt>2^(n-1)，会造成接收方无法分辨新，旧数据分组的问题  

- 接收方的接收窗口尺寸Wr必须满足[1,Wt]，其中Wt为发送窗口尺寸

    > 如果Wr=1，则与回退N帧协议相同
    >
    > 如果Wr>Wt，没有意义



 	   



举例说明，采用3个比特给分组编序号，即序号0~7，如果将发送窗口的Wt设置为5，相应的将接收窗口尺寸Wr也设置为5

![image-20220630223839050](https://picture.xcye.xyz/image-20220630223839050.png)

发送方将0~4号序号中的数据分组发送出去

![image-20220630223931023](https://picture.xcye.xyz/image-20220630223931023.png)

接收方接收他们，并发回确认分组，接收窗口向前滑动5个位置

![image-20220630224015036](https://picture.xcye.xyz/image-20220630224015036.png)

假设这些确认分组到达发送方，但是0号确认分组丢失了

![image-20220630224104289](https://picture.xcye.xyz/image-20220630224104289.png)

发送方接收1~4号确认分组，并记录1~4号数据分组已收到确认，但是发送窗口不能向前移动

![image-20220630224201077](https://picture.xcye.xyz/image-20220630224201077.png)

一段时间后，0号数据分组的重传计时器超时了，发送方重传0号数据分组

![image-20220630224249075](https://picture.xcye.xyz/image-20220630224249075.png)

并被接收方接收，落在0号接收窗口内

![image-20220630224334733](https://picture.xcye.xyz/image-20220630224334733.png)

但是接收方已经接收过0号数据分组了，那么就会出现分组重复这种传输差错，使接收方无法分辨新旧数据分组

![image-20220630224402872](https://picture.xcye.xyz/image-20220630224402872.png)



![image-20220630224627884](https://picture.xcye.xyz/image-20220630224627884.png)

## 点对点协议PPP

   点对点协议PPP(Point-to-Point-Protocol)是世界上目前使用最广泛的点对点数据链路层协议

![image-20220630224829064](https://picture.xcye.xyz/image-20220630224829064.png)

ISP已经从因特网管理机构申请到一批IP地址，用户计算机只有获取到ISP所分配的合法IP地址后，才能称为因特网上的主机，用户计算机与ISP进行通信时，所使用的数据链路层协议通常就是PPP



> PPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661,RFC1662]。





### 组成

PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：

1. 对各种协议数据报的封装方法(封装成帧)
2. 链路控制协议LCP ----> 用于建立，配置以及测试数据链路的链接
3. 一套网络控制协议NCPs ----> 其中的每一个协议支持不同的网络层协议





![image-20220630225844388](https://picture.xcye.xyz/image-20220630225844388.png)





### 帧格式

![image-20220630230431202](https://picture.xcye.xyz/image-20220630230431202.png)

- 帧首部由4个字段构成，帧尾部由2个字段构成

    ![image-20220630230529622](https://picture.xcye.xyz/image-20220630230529622.png)

    ![image-20220630230842073](https://picture.xcye.xyz/image-20220630230842073.png)

    > 当协议字段的取值为0x0021时，帧的数据部分未IP数据报

    

    

- 各字段的长度如下

    ![image-20220630230601619](https://picture.xcye.xyz/image-20220630230601619.png)

- 帧首和帧尾中的标志字段是PPP帧的定界符



### 解决透明传输

![image-20220630231135181](https://picture.xcye.xyz/image-20220630231135181.png)

如果帧的数据部分含有帧首和帧尾中的标志字段时，如果不采取措施，会造成接收方对PPP帧是否结束的误判

> 因为F是PPP帧的定界符，取值为0x7E(01111110)

PPP协议实现透明传输的方法取决于所使用的链路类型

![image-20220630233313908](https://picture.xcye.xyz/image-20220630233313908.png)

- 如果是采用面向字节的异步链路，则采用字节填充法，也就是插入转义字符

    也就是以字节7E作为PPP帧的定界符

    ![image-20220630233426244](https://picture.xcye.xyz/image-20220630233426244.png)

    发送方：

    - 对帧的数据部分出现的每一个7E字节转变成两字节序列(7D,5E)，这相当于在7E字节前插入了转义字符7D，并将7E字节减去十六进制的20，

    - 将出现的每一个7D字节转变成2字节，即7D，5D

    - 将出现的每一个ASCII码控制字符(数值小于0x20的字符)，则在该字符前面插入一个7D字节，同时将该字符的编码加上0x20

        ![image-20220630233916603](https://picture.xcye.xyz/image-20220630233916603.png)

    对于接收方，只要进行反变换即可恢复出原来的PPP帧的数据部分，

- 如果是面向比特的同步链路，则采用比特填充法，也就是插入比特0

    也就是以`01111110`作为PPP帧的定界符

    ![image-20220630234100721](https://picture.xcye.xyz/image-20220630234100721.png)

    如果PPP帧的数据部分如下图，包含了两个帧定界符

    ![image-20220630234210247](https://picture.xcye.xyz/image-20220630234210247.png)





### 差错检测

PPP帧的尾部包含1个两字节的帧检验序列FCS字段，使用循环冗余校验CRC来计算该字段的取值

![image-20220630234400036](https://picture.xcye.xyz/image-20220630234400036.png)





### 工作状态

以拨号接入为例

PPP链路的开始和结束状态都是“静止”状态，这时并不存在物理层的链接，当检测到调制解调器的载波信号，并建立物理层链接后，PPP就进入链路的建立状态，这时链路控制协议LCP开始协商一些配置选项，若协商成功，则进入“鉴别”状态，若协商失败，则进入静止状态，所协商的配置选项包括最大帧长，鉴别协议等，可以不使用鉴别，也可以使用口令鉴别协议PAP或挑战握手鉴别协议CHAP，若通信双方无需鉴别或鉴别身份成功，则进入网络状态，若鉴别失败，则进入终止状态，进入网络状态后，执行NCP配置，配置完成后，就进入打开状态，PPP链路的两端，通过相互交换网络层特定的NCP分组，来进行NCP配置，如果在PPP链路上运行的是IP协议，则使用IP控制协议IPCP，来对PPP链路的每一端配置IP模块，例如分配IP地址，只要链路处于打开状态，就可以进行数据通信，当出现故障或链路的一端发出终止请求时，就进入终止状态，当载波停止后，则回到静止状态

![image-20220630235254724](https://picture.xcye.xyz/image-20220630235254724.png)





## 媒体接入控制的基本概念

共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制`MAC`(Medium Access Control)，这个也就是Mac这个词的由来

![image-20220701172332792](https://picture.xcye.xyz/image-20220701172332792.png)

### 分类

![image-20220701172534835](https://picture.xcye.xyz/image-20220701172534835.png)

> 共享式以太网采用的就是随机接入



随着技术的法阵，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术





### 静态划分信道

复用：是通信技术中的一个重要概念，复用就是通过一条物理线路同时传输多路用户的信号

当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽



![image-20220701173131142](https://picture.xcye.xyz/image-20220701173131142.png)

上图中左边部分是三个用户各自使用一条独立线路进行通信，但是如果像右图所示，在发送端使用`复用器`，在接收端使用`分用器`，那么这三个用户就可以共享一条物理线路进行通信

常见的复用技术有

- 频分复用FDM
- 时分复用TDM
- 波分复用WDM
- 码分复用CDM

> 这部分的内容请看视频讲解[bilibili](https://www.bilibili.com/video/BV1c4411d7jb?p=30&spm_id_from=pageDriver&vd_source=61817999b7f7d61bd68812e2f0dcf85d)	





### 随机接入CSMA/CD协议

随机接入是属于媒体接入控制中的另一类-动态接入控制



![image-20220701173943175](https://picture.xcye.xyz/image-20220701173943175.png)

如上图所示，多个主机连接到一根总线上，当各主机随机发送帧，或者两个或多个主机同时发送帧时，代表帧的信号就会产生碰撞或称为冲突，又或者当某个主机正在使用总线发送帧的过程中，另一台主机也要发送帧，同样也会发生碰撞

![image-20220701174218698](https://picture.xcye.xyz/image-20220701174218698.png)

所以尽量避免产生碰撞，是我们需要解决的一个问题，早期的以太网采用载波监听多址接入/碰撞检测(CSMA/CD协议)来解决这个问题

- 多址接入
    多个站连接在一条总线上，竞争使用总线
    
- 载波监听CS
    每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧(先听后说)
    
    > 96比特时间是指发送96比特的数据所耗费的时间，也称为帧间最小间隔，其作用是使接收方可以检测出一个帧的结束，同时也使得其他站点都有机会平等竞争信道并发送帧
    
    - 若检测到总线空闲96比特时间，则发送这个帧
    - 若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧
    
- 碰撞检测CD
  
    每一个正在发送帧的站边发送边检测碰撞（“边说边听”）
    
    一旦发现总线上出现碰撞，则立即停止发送，退避一段时间后再次发送（“一旦冲突，立即停说，等待时机，重新再说”）



他们的执行过程如下

![image-20220701175248889](https://picture.xcye.xyz/image-20220701175248889.png)

假设主机C要发送帧，它首先进行载波监听，检测到总线空闲96比特时间后，就可以发送帧了

假设在主机C使用总线发送帧的过程中，主机B也要发送帧，主机B也要进行载波监听，发现总线忙，于是持续检测总线，一旦发现总线空闲96比特时间，则立即发送帧

![image-20220701175541191](https://picture.xcye.xyz/image-20220701175541191.png)

边发送帧，还要边检测碰撞，只要没有检测到碰撞，则可继续发送帧的剩余部分

![image-20220701175624083](https://picture.xcye.xyz/image-20220701175624083.png)

假设在主机B发送帧的过程中，主机C也还要发送帧，主机C进行载波监听，发送总线空闲96比特时间后立即发送帧，这个必然会产生碰撞(`因为主机B也还在发送剩余帧，那么主机B必然也能检测到总线空闲，所以主机C和主机B会同时发送帧，就产生了信号碰撞`)，在产生碰撞时刻，主机B和主机C都在边发送帧边检测碰撞

![image-20220701175806399](https://picture.xcye.xyz/image-20220701175806399.png)

但都检测不到碰撞(我的理解是，碰撞时刻，他们都发送一个信号延着他们各自的方向检测，但是这个时刻，主机B和主机C碰撞，那么检测碰撞的信号是相反的)，碰撞信号沿总线传播，主机C会比主机B更早检测到碰撞并停止发送，退避一段时间，重新再发送之前所发送的帧

![image-20220701175933266](https://picture.xcye.xyz/image-20220701175933266.png)

当主机B检测到碰撞后，立即停止发送，退避一段随机时间，再发送之前所发送的帧

![image-20220701180023602](https://picture.xcye.xyz/image-20220701180023602.png)

> 以太网还采用了一种叫强化碰撞的措施，当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32比特或者48比特的人为干扰信号，以便有足够多的碰撞信号使所有站点都能检测出碰撞



### CSMA/CD协议-争用期(碰撞窗口)

![image-20220701182542872](https://picture.xcye.xyz/image-20220701182542872.png)

上图中，主机A和主机D处于总线型以太网的两端，以太网单程端到端的传播时延记为tao，纵坐标为时间，假设在时刻0主机A要发送帧，当检测到总线空闲96比特时间后，立即发送帧，在时刻(tao-德尔塔)主机D也要发送帧，当检测96比特时间总线空闲后(实际上总线并不空闲，只是主机D检测不出来)，立即发送帧

他们必然会产生碰撞，发生碰撞的时间为(tao-德尔塔/2),之后碰撞信号会陆续传播到主机D和主机A，主机D检测到碰撞的时刻为tao，而主机A检测到碰撞的时刻为(2tao-德尔塔 )

- 主机最多经过2tao(德尔塔-->0)的时长就可检测到本次发送是否遭受了碰撞

- 以太网的端到端往返时延2tao称为争用期或碰撞窗口

- 经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会碰撞

- 每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性，这一小段时间是不确定的，它取决于另一个发送帧的主机到本机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间

- 在以太网发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大，因此，共享式以太网不能连接太多的主机，使用的总线也不能太长

    10Mb/s以太网把争用期定位512比特发送时间，即51.2us，因此其总线长度不能超过5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过2500m



> 对于CSMA/CD这部分的内容，我都没学，直接看原视频
>
> https://www.bilibili.com/video/BV1c4411d7jb?p=31&spm_id_from=pageDriver&vd_source=61817999b7f7d61bd68812e2f0dcf85d



## Mac地址

- 数据链路层

    Mac地址是以太网的MAC子层所使用的地址

- 网际层

    IP地址是TCP/IP体系结构网际层所使用的地址

    ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址

尽管IP地址和ARP协议属于TCP/IP体系结构的网际层，而不属于数据链路层，但是他们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址，IP地址以及ARP协议



> 对于使用点对点信道的数据链路层不需要使用地址

![image-20220701211841911](https://picture.xcye.xyz/image-20220701211841911.png)

因为上图是一个点对点链接的，所以他们之间不需要使用地址



![image-20220701211813224](https://picture.xcye.xyz/image-20220701211813224.png)

但是对于上图来说，这是一个总线型的网络，如果主机C向主机D发送帧，那么这5台主机都会都到主机C发送的消息，那么如何判断主机C发送的数据是不是给自己的呢？

为了解决这个问题，我们就必须为每个主机都使用一个唯一标识来标记，即一个`数据链路层地址`

在每个主机发送的`帧中必须携带标识发送主机和接收主机的地址`，由于这类地址是用于媒体接入控制MAC(Media Access Control)，因此这类地址也叫做`MAC地址`

> MAC地址一般被固化在网卡(网络适配器)的电可擦编程只读存储器EEPROM中，因此MAC地址也被称为`硬件地址`
>
> MAC地址有时也被称为`物理地址`，但是并不意味着MAC地址属于网络体系结构中的物理层



![image-20220701212435024](https://picture.xcye.xyz/image-20220701212435024.png)



一般情况下，用户主机会包含两个网络适配器，有线局域网适配器(有线网卡)和无线局域网适配器(无线网卡)，每个网络适配器都有一个全球唯一的MAC地址，而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址(比如交换机一个接口就拥有一个MAC地址)

> MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识





### IEEE 802局域网的MAC地址格式

![image-20220701213943947](https://picture.xcye.xyz/image-20220701213943947.png)

生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI，后三个字节是获得OUI的厂商可自行分配的，对于48比特的MAC地址，可以称为`EUI-48`，MAC地址的表示方法是将每4个比特写成一个`十六进制的字符`，总共有12位，可将每两个字符分成一组，共有6组，在不同系统或者软件中，转换成十六进制的MAC地址的表示方法会有不同

- 标准表示法：每两个之间使用`-`隔开

    `xx-xx-xx-xx-xx-xx`

- 在Linux，mac中，会使用`:`隔开

- 在一些软件中，每4个字符一组，使用`.`隔开

    `xxxx.xxxx.xxxx`

> 对于已在IEEE注册的OUI，我们可以在http://standards-oui.ieee.org/oui.txt中查看
>
> 







### 单播地址和多播地址

![image-20220701215832949](https://picture.xcye.xyz/image-20220701215832949.png)

所以一共有4类MAC地址

![image-20220701215852029](https://picture.xcye.xyz/image-20220701215852029.png)

> 因为常见的MAC地址都是以12个字符表示的，每个字符时4比特，第一字节被转换成了两个十六进制的字符，所以在判断一个MAC地址属于哪一类的时候，我们需要取第二个字符，因为第二个字符就是48比特中，第一字节的4~8位转换成的十六进制数，然后我们在将十六进制的第二个字符先转换成10进制，然后在转换成2进制，就可以判断了
>
> 比如`FC:AB:90:8F:23:26`，十六进制的C转换成2进制为`1100`，其中b0位是0，b1位是1，所以这个MAC地址是全球管理，单播地址

> 全球管理的单播地址是厂商生产网络设备时给设备的各网络接口固化的MAC地址
>
> 全球管理的多播地址是标准网络设备所应支持的多播地址，用于特定功能，例如交换机生成树协议所需要的多播地址
>
> 本地管理的单播地址由网络管理员分配，这种类型的地址会覆盖网络接口的全球管理单播地址，也就是本地管理单播地址优先级高于全球管理单播地址
>
> 本地管理的多播地址用于用户对主机的软件配置，以表明该主机属于哪些多播组
>
> > `当剩余46比特全为1时，就是广播地址FF-FF-FF-FF-FF`，比如一个主机向MAC地址为`FF-FF-FF-FF-FF`的
>
> 因为MAC地址由48比特构成，每个比特的值有0和1，所以总共有`2^48`个MAC地址，也就是二百八十多万亿个
>
> 因为每个人都会有多个设备，而且有些设备的MAC地址不止一个，IEEE的目标寿命为100年，到2080年停止，但是鼓励采用EUI-64作为替代



 

#### MAC地址发送顺序

![](https://picture.xcye.xyz/image-20220701221749618.png)



### 单播MAC地址作用

![image-20220701222255120](https://picture.xcye.xyz/image-20220701222255120.png)

假设主机B要给主机C发送单播帧，主机B首先要构建该单播帧，在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段，数据载荷以及帧尾部，就构成了一个单播帧

主机B将该单播帧发送出去，主机A和C都会收到该单播帧，主机A的网卡发现该单播帧中的目的地址与自己的MAC地址不匹配，会丢弃该帧，主机C的网卡发现该单播帧的目的MAC地址与自己的MAC地址相同，于是接收该帧并将该帧交给其上层处理

![image-20220701222502931](https://picture.xcye.xyz/image-20220701222502931.png)



#### 广播MAC地址的作用

![image-20220701222731811](https://picture.xcye.xyz/image-20220701222731811.png)

假设主机B要发送一个广播帧，主机B首先要先构建该广播帧，在帧首部中的目的地址字段填入广播地址`FF-FF-FF-FF-FF-FF`，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段，数据载荷以及帧尾部，就构成了该广播帧，主机B将该广播帧发送出去

主机A和主机C都会收到该广播帧，发现该帧首部的目的地址字段的内容是广播地址，都会接收该帧，然后将该帧交给上层处理

![image-20220701222859237](https://picture.xcye.xyz/image-20220701222859237.png)



#### 多播MAC地址作用

![image-20220701223448551](https://picture.xcye.xyz/image-20220701223448551.png)

假设主机A要发送多播帧给该多播地址，将该多播地址的第一个字节写成8比特，可以看到最低比特位为1，表明该MAC地址是一个多播地址

> 快速判断一个MAC地址是否是多播地址的方法
>
> 如果`07-E0-12-F6-2A-D8`中的第二个字符不能整除2(1,3,5,7,9,B,D,F)，则这个MAC地址就是一个多播地址



![image-20220701223944809](https://picture.xcye.xyz/image-20220701223944809.png)

从上图可以看出，主机B和主机C都属于两个多播组，而主机D不属于任何多播组，主机A首先要构建该多播帧，在帧首部的目的地址字段填入该多播地址，源地址填入自己的MAC地址，还有首部其他字段，数据载荷，帧尾部，然后将该多播帧发送出去

![image-20220701224230796](https://picture.xcye.xyz/image-20220701224230796.png)

主机BCD都会收到该多播帧，主机B和主机C都发现此多播帧的目的MAC地址在自己的多播组中，接收该帧，并交付给上层处理，而主机D发现该多播帧的目的MAC地址不在自己的多播组中，丢弃该帧

![image-20220701224434337](https://picture.xcye.xyz/image-20220701224434337.png)

> 当给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址



### 随机MAC地址

美国国家安全局有一套系统可以通过监控电子设备的MAC地址，来跟踪城市中每个人的行动，因此很多设备厂商，都在扫描网络时采用随机MAC地址技术



![image-20220701224813752](https://picture.xcye.xyz/image-20220701224813752.png)

## IP地址

> IP地址是属于网络层，MAC地址是属于数据链路层，是因特网上的主机和路由器所使用的地址，用于标识两部分信息
>
> - 网络编号：标识因特网上数以百万计的网络，比如192.168.0.1中的192.168.0部分
> - 主机编号：标识同一网络上不同主机（或路由器各接口），比如192.168.0.1和192.168.0.2中的1和2就是用于区别同一网络中的两台计算机





![image-20220701230721373](https://picture.xcye.xyz/image-20220701230721373.png)

上图网络中，N8下的两台主机的网络编号应该和路由器R4的网络编号部分相同，主机编号部分不同



> MAC地址不具备区分不同网络的功能，但是IP地址可以
>
> 如果只是一个单独的网络，不接入因特网，可以只使用MAC地址
>
> 如果主机所在的网络要加入因特网，则IP地址和MAC地址都需要使用



### IP地址和MAC地址的封装位置

![image-20220701231237736](https://picture.xcye.xyz/image-20220701231237736.png)

> 上图中的黑色表示，该层不需要知道上层发送的数据具体内容是什么，不需要管

因为IP地址属于TCP/IP体系结构中的网络层，所以在网络层首部中应该封装有源IP地址和目的IP地址，而MAC地址属于数据链路层的范畴，因此在数据链路层首部中应该封装有源MAC地址和目的MAC地址





### IP地址和MAC地址在转发中的变化

![image-20220701231626038](https://picture.xcye.xyz/image-20220701231626038.png)

> 上图中MAC地址和IP地址只是简单的表示出来

假设主机H1需要给主机H2发送数据包

1. 主机H1将数据发送给路由器R1，在网络层封装的IP数据报首部中，源IP地址应填写主机H1的IP地址IP1，目的IP地址应填写主机H2的IP地址IP2

    ![image-20220701231838889](https://picture.xcye.xyz/image-20220701231838889.png)

2. 而在数据链路层的封装的帧首部中，源MAC地址应填写主机H1的MAC地址MAC1,而目的MAC地址应填写路由器R1的MAC地址MAC3，也就是从MAC1发送给MAC3

    ![image-20220701232143935](https://picture.xcye.xyz/image-20220701232143935.png)
    
3. 路由器R1将收到的数据包转发给路由器R2，在网络层封装的IP数据报首部中，源IP地址仍填写主机H1的IP地址IP1，目的IP地址仍填写主机H2的IP地址IP2，在数据链路层封装的帧首部中，源MAC地址应该填写R1 的源MAC地址MAC4，目的MAC地址填写路由器R2的MAC地址MAC5

    ![image-20220701232450787](https://picture.xcye.xyz/image-20220701232450787.png)

4. 路由器R2将收到的数据包转发给主机H2，在网络层封装的IP数据报首部中，源IP地址仍然是主机H1的，目的IP地址是主机H2的，但在数据链路层封装的帧首部中，源MAC地址为MAC6，目的MAC地址为MAC2

    ![image-20220701232649084](https://picture.xcye.xyz/image-20220701232649084.png)

> 数据包转发过程中，源IP地址和目的IP地址保持不变，但是源MAC地址和目的MAC地址逐个链路（或逐个网络）改变



![image-20220701232850915](https://picture.xcye.xyz/image-20220701232850915.png)

## 地址解析协议ARP

![image-20220701233958203](https://picture.xcye.xyz/image-20220701233958203.png)

上图中，主机B需要向主机C发送数据包，主机B知道主机C的IP地址，但是不知道MAC地址，所以主机B在封装数据帧时，就无法填写目的MAC地址字段，也就无法构建出要发送的MAC帧

但是实际上，每台主机都会有一个ARP高速缓存表

![image-20220701234213989](https://picture.xcye.xyz/image-20220701234213989.png)

在高速缓存表中，记录有IP地址和MAC地址的对应关系，如果主机B向主机C发送数据包时，会现在自己的高速缓存表中查找主机C的IP地址所对应的MAC地址

![image-20220701234429954](https://picture.xcye.xyz/image-20220701234429954.png)

如果没有找到，则主机B需要发送ARP请求报文（广播），此ARP请求报文的内容为（白话文构建，实际上ARP请求报文有其自己的格式）

![image-20220701234538061](https://picture.xcye.xyz/image-20220701234538061.png)

> ARP请求报文被封装在MAC帧中发送，目的地址为广播地址`FF-FF-FF-FF-FF-FF`

主机B发送ARP请求报文，总线上的其他主机都能收到

![image-20220701234743162](https://picture.xcye.xyz/image-20220701234743162.png)

主机A的网卡收到该广播帧后，送交上层处理，上层的ARP进程解析ARP请求报文，发现所询问的IP地址不是自己的IP地址，不予理会，主机C的网卡收到广播帧后，送交上层处理，上层的ARP进程解析ARP请求报文，发现所询问的IP地址正是自己的IP地址，需要进行响应

![image-20220701235035329](https://picture.xcye.xyz/image-20220701235035329.png)



主机C首先将B的IP地址与MAC地址记录到自己的高速缓存表中，然后给主机B发送ARP响应报文，以告知自己的MAC地址

![image-20220701235212481](https://picture.xcye.xyz/image-20220701235212481.png)

响应报文的内容是

![image-20220701235235868](https://picture.xcye.xyz/image-20220701235235868.png)

> ARP响应报文被封装在MAC帧中发送，目的地址为主机B的MAC地址

主机C给主机B发送封装有ARP响应报文的单播帧，总线上的其他主机都能收到该单播帧，主机A的网卡收到该单播帧后，主机A的网卡发现单播帧的目的MAC地址不是自己，丢弃，主机B的网卡发现单播帧的目的MAC是自己，交付上层处理，上层的ARP进程解析ARP响应报文，将其所包含的主机地址和MAC地址记录在自己的高速缓存表中

![image-20220701235601944](https://picture.xcye.xyz/image-20220701235601944.png)

![image-20220701235618865](https://picture.xcye.xyz/image-20220701235618865.png)

然后主机B就可以继续给主机C发送数据包了

> ARP高速缓存表中的记录都有其类型，分为动态和静态，动态类型是指记录是主机自动获取到的，其生命周期默认为两分钟，当生命周期结束时，该记录会自动删除
>
> 因为MAC地址与IP地址的对应关系并不是永久的，例如更换网卡后，主机IP地址不变，但是MAC地址改变了
>
> 静态类型是指记录是用户或网络维护人员手动配置的，不同操作系统下的生命周期不同



问题？

![image-20220702000017839](https://picture.xcye.xyz/image-20220702000017839.png)

> ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用，对于上图，ARP协议是逐个链路进行的



![image-20220702000138104](https://picture.xcye.xyz/image-20220702000138104.png)



## 集线器和交换机的区别

![image-20220702221153902](https://picture.xcye.xyz/image-20220702221153902.png)

上图就是一个使用集线器和双绞线电缆，互连四台主机的星型拓扑的以太网，交换机和电缆是使用`RJ-45`接头进行链接的，也就是水晶头

> 使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是`CSMA/CD`协议

集线器只工作在物理层，它的每个接口仅简单的转发比特，不进行碰撞检测（由各站的网卡检测）



集线器一般都有少量的容错能力和网络管理功能，例如，若网络中某个网卡出了故障，不停的发送帧，此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连接，使整个以太网仍然能正常工作



![image-20220702221827599](https://picture.xcye.xyz/image-20220702221827599.png)

例如对于上面的这个网络，如果一系中的某台主机给二系中的某台主机发送数据帧，

由于总线特性，表示该数据帧的信号，会传输到整个网络中的其他各主机

![image-20220702222725581](https://picture.xcye.xyz/image-20220702222725581.png)

在集线器之后，发展出了更先进的网络互连设备-以太网交换机



![](https://picture.xcye.xyz/image-20220702222828595.png)

上图中，使用集线器链接的网络中的一台主机向另一台主机发送数据帧，因为总线，会发送到总线上的各台主机，但是如果使用交换机进行链接，并不会出现这样的效果





![image-20220702223045551](https://picture.xcye.xyz/image-20220702223045551.png)

1. 以太网交换机通常都有多个接口，每个接口都可以直接与一台主机或另一个以太网交换机相连，一般都工作在全双工模式下

2. 以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞(不使用CSMA/CD协议)

3. 以太网交换机一般都具有多种速率的接口，例如10Mb/s

4. 以太网交换机工作在数据链路层，也包括物理层，它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，人饭后通过该接口转发帧

    ![image-20220702224333017](https://picture.xcye.xyz/image-20220702224333017.png)

    比如上图，如果主机A向主机B发送帧，交换机收到该帧后，在交换机的帧交换表中查找该帧的目的MAC地址，发现是主机B的MAC地址，应该从接口2转发

    ![image-20220702224507207](https://picture.xcye.xyz/image-20220702224507207.png)

5. 以太网交换机时一种即插即用的设备，其内部的帧交换表示通过自学习算法自动逐渐建立起来的

6. 帧的两种转发方式
    - 存储转发

    - 直通方式，采用基于硬件的交叉矩阵（交换时延非常小，但不检查帧是否有差错）

        直通方式不必把整个帧先缓存后再进行处理，在接收帧的同时，就立即按帧的目的MAC地址决定该帧的转发接口，因而提高了帧的转发速率
    
    
    
    
    
    
    
    

### 集线器和交换机的不同比较

#### 发送单播帧

![image-20220702225021508](https://picture.xcye.xyz/image-20220702225021508.png)

对于使用集线器的网络，如果某个主机向另一个主机发送单播帧，那么在该总线上的其他主机都会收到该单播帧，这些主机根据单播帧中的目的MAC地址决定是否接收该单播帧

而对于使用交换机的网络来说，某台主机向另一台主机发送单播帧，交换机并不会将此单播帧转发多其他所有的主机上，只会转发到该单播帧目的MAC地址在帧交换表中所对应的接口上



#### 发送广播帧

![image-20220702225330393](https://picture.xcye.xyz/image-20220702225330393.png)

在使用集线器的网络中，如果一台主机发送广播帧，那么整个网络中的其他主机都能够收到该广播帧，这些主机查看该帧时广播帧，都会接收该广播帧

对于使用交换机的交换式以太网，交换机收到广播帧后，检测到帧的物理MAC地址是广播地址，于是从除该帧进入交换机接口外的其他各接口转发该帧，网络中除源主机之外的其他各主机收到广播帧后，接受该广播帧

> 对于发送广播帧的情况，使用集线器和交换机都没有什么区别





#### 主机向另一台主机发送单播帧

![image-20220702225747309](https://picture.xcye.xyz/image-20220702225747309.png)

对于使用集线器的共享总线型以太网，他们必然会遭遇碰撞，遭遇碰撞的帧会传播到总线上的各主机

![image-20220702225851759](https://picture.xcye.xyz/image-20220702225851759.png)

![image-20220702225907416](https://picture.xcye.xyz/image-20220702225907416.png)



对于使用交换机的交换式以太网，交换机收到多个帧时，会将他们缓存起来，然后逐个转发给目的主机，不会产生碰撞

![image-20220702230056008](https://picture.xcye.xyz/image-20220702230056008.png)

![image-20220702230140702](https://picture.xcye.xyz/image-20220702230140702.png)





#### 使用集线器扩展和交换机扩展以太网

- 发送单播帧

    ![image-20220702230228421](https://picture.xcye.xyz/image-20220702230228421.png)

- 发送广播帧

    ![image-20220702230308842](https://picture.xcye.xyz/image-20220702230308842.png)

- 另一种情况

    ![image-20220702230354628](https://picture.xcye.xyz/image-20220702230354628.png)





![image-20220702230422577](https://picture.xcye.xyz/image-20220702230422577.png)

> 如果仅使用集线器来扩展以太网，不仅会扩大广播域还同时扩大了碰撞域
>
> 如果使用交换机将原来各自独立的碰撞域连接起来，只会扩大广播域，不会扩大碰撞域，也就是说，交换机可以隔离碰撞域





### 交换机自学习和转发帧的流程

> 以太网交换机工作在数据链路层（也包括物理层），目前市场上也有包含网络层部分功能的交换机称为`三层交换机`



以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧，他是一种即插即用的设备，刚上电时其内部的帧交换表是空的，随着网络中各主机间的通信，以太网交换机通过`自学习算法`自动逐渐建立起`帧交换表`



![image-20220703065356824](https://picture.xcye.xyz/image-20220703065356824.png)

上图中各设备固化的MAC地址使用他们对应的大写字母表示，并且假设主机已经知道了网络中其他各主机的MAC地址，也就是不需要首先通过ARP来获取目的主机的MAC地址



交换机的自学习算法过程如下

1. 假设主机A给主机B发送帧，A从交换机的1口进入交换机中，交换机首先进行登记工作，将该帧的源MAC地址A记录该自己的帧交换表中，将该帧进入自己的接口的接口号1也记录到帧交换表中，这个过程称为交换机的`自学习`

    ![image-20220703070135713](https://picture.xcye.xyz/image-20220703070135713.png)

2. 之后交换机对该帧进行转发，该帧的目的MAC地址为B，在帧交换表中查找MAC地址为B的记录，找不到

    ![image-20220703070239101](https://picture.xcye.xyz/image-20220703070239101.png)

    于是对该帧进行盲目的转发(也称为`泛洪`)，也就是从除进入该交换机的其他所有接口转发该帧

    ![image-20220703070405983](https://picture.xcye.xyz/image-20220703070405983.png)

3. 主机B的网卡收到该帧后，根据帧的目的MAC地址，就知道这是发送给自己的帧，于是就接受该帧，主机C的网卡收到该帧后，发现不是发送给自己的，于是就丢弃该帧

    ![image-20220703070611901](https://picture.xcye.xyz/image-20220703070611901.png)

4. 该帧从交换机2的接口2进入交换机2，交换机2首先进行登记工作，将该帧的源MAC地址A记录到自己的帧交换表中，将该帧进入自己的接口2也记录到帧交换表中

    ![image-20220703070757371](https://picture.xcye.xyz/image-20220703070757371.png)

5. 之后交换机2对该帧进行转发，在交换机2的帧交换表中查找MAC地址为B的记录，找不到，于是对该帧进行盲目的转发（泛洪）

    ![image-20220703070922036](https://picture.xcye.xyz/image-20220703070922036.png)

    主机EFD都会收到该帧，因为都不是发送给自己的，所以都丢弃该帧

    ![image-20220703071016824](https://picture.xcye.xyz/image-20220703071016824.png)

6. 因为主机B接受了该帧，所以主机B需要对该帧进行响应，B给A发送帧，从交换机1的接口3进入交换机中，交换机首先进行登记工作，将帧的源MAC地址记录到帧交换表中以及接口3

    ![image-20220703071211207](https://picture.xcye.xyz/image-20220703071211207.png)

7. 交换机对该帧进行转发，目的MAC地址为A，在帧交换表中可以查到，于是从接口1转发，这是明确的转发，主机A的网卡收到该帧后，根据目的MAC地址，就知道是发送给自己的，其他的接口都不会收到该帧，因为只向接口1进行转发

    ![image-20220703071413965](https://picture.xcye.xyz/image-20220703071413965.png)

8. 如果主机E给主机A发送帧，过程也和上面是一样的，通过这种自学习的过程，一个新的交换机就能够建立起一张完整的帧交换表，在开始的时候，效率会比较低，但是当建立起完整的帧交换表之后，转发帧就会很快

    ![image-20220703071709433](https://picture.xcye.xyz/image-20220703071709433.png)



#### 交换机丢弃帧的情况

![image-20220703071826121](https://picture.xcye.xyz/image-20220703071826121.png)

比如上图，在交换机的接口1处在链接了一台主机，他们是使用集线器进行连接的，这里没有画出，这样主机A和G就共享了同一条总线

如果主机G发送帧给A，其过程为

1. 主机A和交换机1的接口1都可以收到该帧

    ![image-20220703072021711](https://picture.xcye.xyz/image-20220703072021711.png)

2. 主机A的网卡收到该帧后，发现目的MAC地址是自己的，于是接受该帧，交换机1收到该帧后，首先进行登记工作

    ![image-20220703072124578](https://picture.xcye.xyz/image-20220703072124578.png)

    之后对该帧进行转发，在帧交换表中查找MAC为A的记录，可以找到，对应的接口为1，因为1号接口是该帧进入交换机的接口，所以交换机1不会再从该接口将该帧转发出去，因为这是没有必要的，于是丢弃该帧

    ![image-20220703072323359](https://picture.xcye.xyz/image-20220703072323359.png)

    交换机2不会收到该帧，因为没有进行泛洪转发



![image-20220703072419270](https://picture.xcye.xyz/image-20220703072419270.png)

> 帧交换表中的每条记录都有自己的有效时间，到期都会自动删除
>
> 这是交换机的接口和MAC地址并不是永久性的，比如交换机某接口所连接的主机更换成了另一台主机，又或者主机中的网卡坏了，更换成另外的网卡，这些情况都会使MAC地址发生改变



![image-20220703072649931](https://picture.xcye.xyz/image-20220703072649931.png) 

![image-20220703072711244](https://picture.xcye.xyz/image-20220703072711244.png)

![image-20220703072739213](https://picture.xcye.xyz/image-20220703072739213.png)



### 以太网交换机生成树协议STP

![image-20220703074002269](https://picture.xcye.xyz/image-20220703074002269.png)

如果交换机A与B之间的链路出现故障，则交换机B上连接的所有主机，既无法与交换机A上连接的所有主机进行通信，也无法与交换机C上连接的所有主机进行通信 

![image-20220703074152757](https://picture.xcye.xyz/image-20220703074152757.png)

如果交换机A与交换机B和C之间的链路都出现了故障，则原来的以太网变成了三个独立的较小的以太网

![image-20220703074301152](https://picture.xcye.xyz/image-20220703074301152.png)

![image-20220703074315134](https://picture.xcye.xyz/image-20220703074315134.png)

他们之间不能相互通信

> 可以添加冗余链路的方法，提高以太网的可靠性



![image-20220703074403118](https://picture.xcye.xyz/image-20220703074403118.png)

如上图，当在B和C之间添加一条冗余链路后，即使A和B之间的链路出现故障，整个网络还是连接的

![image-20220703074520128](https://picture.xcye.xyz/image-20220703074520128.png)

但是冗余链路也会带来负面效应，会形成`网络环路`，如下图

![image-20220703074606179](https://picture.xcye.xyz/image-20220703074606179.png)

网络环路带来的问题

- 广播风暴

    假设主机H1发送广播帧，交换机B收到该帧后，将其从自己的所有接口转发出去

    ![image-20220703074711586](https://picture.xcye.xyz/image-20220703074711586.png)

    交换机A收到交换机B转发来的帧后，将其从自己的所有接口转发出去

    ![image-20220703074750957](https://picture.xcye.xyz/image-20220703074750957.png)

    交换机C收到交换机B转发来的广播帧后，从自己的其他所有接口转发出去

    ![image-20220703074847997](https://picture.xcye.xyz/image-20220703074847997.png)

    交换机A收到交换机C转发的帧后，从自己的其他所有接口转发出去

    ![image-20220703074935961](https://picture.xcye.xyz/image-20220703074935961.png)

    同样的，交换机A收到交换机C转发的帧后，从自己的其他所有端口转发出去

    ![image-20220703075041388](https://picture.xcye.xyz/image-20220703075041388.png)

    交换机B收到交换机C转发来的帧后，将其从自己的其他所有接口转发出去

    ![image-20220703075126847](https://picture.xcye.xyz/image-20220703075126847.png)

    交换机B收到交换机A转发的帧后，从自己的其他接口转发出去

    ![image-20220703075200779](https://picture.xcye.xyz/image-20220703075200779.png)

    > 最终该广播帧，将在各交换机之间反复转发，分别按顺时针和逆时针方向同时兜圈，这就是所谓的`广播风暴`
    >
    > 广播风暴会大量消耗网络资源，使得网络无法正常转发其他数据帧，也会使主机反复收到该广播帧，大量消耗主机资源，还会使交换机的帧交换表震荡

    

    - 交换机的帧交换表震荡（漂移）是指

        ![image-20220703075610391](https://picture.xcye.xyz/image-20220703075610391.png)

        因为不断会有广播从不同的接口进入交换机B，所以交换机B的帧交换表中MAC地址为H1的记录的接口在不断的变化，当有MAC为H1的新接口时，会删除原来的H1对应的接口信息

    

    > 以太网交换机可以使用生成树协议STP(Spanning Tree Protocol)可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题，无论交换机之间采用怎样的物理链接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑接口必须是树形的（无逻辑环路）

    

    ![image-20220703080056908](https://picture.xcye.xyz/image-20220703080056908.png)

    上图中，各交换机连接的主机没有画出

    

    交换机使用STP协议之后，就会自动计算出该阻塞哪些接口

    ![image-20220703080252136](https://picture.xcye.xyz/image-20220703080252136.png)

    这样就会形成一个逻辑上没有环路的网络 

    ![image-20220703080323372](https://picture.xcye.xyz/image-20220703080323372.png)

    > 最终生成的树型逻辑拓扑要确保连通整个网络，否则就没有任何意义

    当首次连接交换机或网络物理拓扑发生变化时（有可能是人为变化或故障），交换机都将进行生成树的重新计算

    例如，如果下面这个链路出现故障

    ![image-20220703080551033](https://picture.xcye.xyz/image-20220703080551033.png)

    交换机检测到该故障后，会自动计算，并重新计算生成树，决定将之前自己阻塞的接口恢复为正常状态

    ![image-20220703080651182](https://picture.xcye.xyz/image-20220703080651182.png)

    就会形成一个新的逻辑上没有环路的网络

    
    
## 虚拟局域网VLAN

使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一个广播域，随着交换式以太网规模的扩大，广播域也会相应的扩大，巨大的广播域会带来的弊端：

1. 广播风暴
2. 难以管理和维护
3. 潜在的安全问题



在以太网中会频繁使用到广播的有

1. TCP/IP协议栈中的很多协议都会使用广播
    - 地址解析协议ARP（一直IP地址，找出其对应的MAC地址）
    - 路由信息协议RIP（一种小型的内部路由协议）
    - 动态主机配置协议DHCP（用于自动配置IP地址）
2. NetBEUI：Windows下使用的广播型协议
3. IPX/SPX：Novell网络的协议栈
4. Apple Talk：Apple公司的网络协议栈



分割广播域的方法：

1. 使用路由器可以隔离广播域

    ![image-20220703220008073](https://picture.xcye.xyz/image-20220703220008073.png)

    上图为由两台交换机连接成的交换式以太网，网络中的各主机同属于一个广播域，使用路由器可以将该广播域分割成两个较小的广播域

    ![image-20220703220131481](https://picture.xcye.xyz/image-20220703220131481.png)

    路由器工作在网络体系结构的第三层

    > 使用路由器的原因是：
    >
    > 默认情况下，路由器不对广播数据包进行转发，因此使用路由器就可以很自然的隔离广播域，但是路由器的成本比较高，直接使用路由器来隔离有点不太现实







`虚拟局域网VLAN（Virtual Local Area Network）`是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求



![image-20220703220502617](https://picture.xcye.xyz/image-20220703220502617.png)

上图组成了一个很大的局域网

![image-20220703220540537](https://picture.xcye.xyz/image-20220703220540537.png)

每一层楼都成为了整个局域网的一个网段

![image-20220703220618525](https://picture.xcye.xyz/image-20220703220618525.png)

某台主机发送数据包，其他所有的主机都可以收到

![image-20220703220700606](https://picture.xcye.xyz/image-20220703220700606.png)

如上图，如果我们使用VLAN技术将整个广播域分成两个VLAN，那么在VLAN1中的广播数据包不会传送到VLAN2，同理VLAN2的也不会传送到VLAN1，同一个VLAN内部可以广播通信，不同VLAN之间不能进行广播通信 



### 虚拟局域网VLAN的实现机制

虚拟局域网技术是在交换机上实现的，但是需要交换器能够实现两个功能

1. 能够处理带有VLAN标记的帧，也就是`IEEE 802.1Q`帧
2. 交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同





#### IEEE 802.1Q帧

​	IEEE 802.1Q帧也称为Dot One Q帧，是对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记

![image-20220703221320869](https://picture.xcye.xyz/image-20220703221320869.png)

> VLAN标记的自后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪一个VLAN，VID的取值范围是0~4095(0~2^12-1)，但是0和4095都不用来表示VLAN，因此用于表示VLAN的VID的有效取值范围是1~4094



802.1Q帧是由交换机来处理的，而不是用户主机来处理的，当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称“打标签”，当交换机转发802.1Q帧时，可能会删除其4字节的VLAN标记转变为普通以太网帧，简称“去标签”



#### 交换机的端口类型

> 交换机的缺省VLAN ID
>
> 在思科交换机上称为Nati(本征VLAN)，例如思科交换机在用户未配置VLAN时，所有端口都默认属于VLAN1，即所有端口的本征VLAN都是VLAN1，而在华为交换机上将其称为“端口VLAN ID”，简称为PVID
>
> > `交换机的每个端口有且仅有一个PVID`



#### Access端口

- Access端口：一般用于连接用户计算机，只能属于一个VLAN，因此Access端口的PVID值与端口所属VLAN的ID相同

    ![image-20220703222250368](https://picture.xcye.xyz/image-20220703222250368.png)

    上图中，当插上电时，默认配置个端口都属于VLAN1，默认配置各端口的类型为Access（这里使用大写A表示）

    Access端口的接收处理方法是：

    1. 一般只接受“未打标签”的普通以太网MAC帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相同

    2. 假设主机A发送了一个广播帧，该帧从交换机的端口1进入交换机，由于端口1的类型是Access，它会对接收到的“未打标签”的普通以太网MAC帧“打标签”，也就是插入4字节的VLAN标记字段

        ![image-20220703222756809](https://picture.xcye.xyz/image-20220703222756809.png)

    3. 由于端口1的PVID值等于1，因此所插入的4字节VLAN标记字段中的VID的值也等于1，Access端口的处理方法是

    4. 若帧中的VID与端口的PVID相等，则“去标签”后转发该帧，否则不转发

        在上图中，广播帧的VID的取值与端口2,3,4的PVID取值都等于1，因此交换机会从这三个端口对帧进行“去标签”转发

        ![image-20220703223059617](https://picture.xcye.xyz/image-20220703223059617.png)
        

如果现在需要将AB划归到VLAN2，将CD主机划归到VLAN3，那么我们可以再交换机上创建VLAN2和VLAN3，然后将端口1和2添加到VLAN2，将端口2,4添加到VLAN3
    ![image-20220703223750089](https://picture.xcye.xyz/image-20220703223750089.png)

那么现在主机A发送一个广播帧，Access端口处理的过程如下：

1. 该帧从交换机的端口1进入交换机，由于端口1的类型是Access，它会对接收到的“未打标签”的普通以太网MAC帧“打标签”，也就是插入4字节的VLAN标记字段，由于端口1的PVID值等于2，所以所插入的4字节标记字段中的VID的值也等于2

    ![image-20220703224131327](https://picture.xcye.xyz/image-20220703224131327.png)

2. 因此端口2的PVID值等于帧中的VID的值，所以交换机会从端口2对帧进行“去标签”转发

    ![image-20220703224240990](https://picture.xcye.xyz/image-20220703224240990.png)

    

#### Trunk端口

Trunk端口一般用于交换机之间或交换机与路由器之间的互连，他可以属于多个VLAN，而Access就只能属于一个VLAN，用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1

![image-20220703225041379](https://picture.xcye.xyz/image-20220703225041379.png)

如图我们需要将abef添加到VLAN1，将cdgh添加到VLAN1，因为路由器通电后，默认的端口类型为Access，所有主机都属于VLAN1，我们需要做的操作有，在交换机上创建VLAN2，将cdgh添加到VLAN2中，将abef添加到VLAN1，并修改他们的PVID值

还需要将讲个交换机互连的端口5的端口类型修改为Trunk，他们的PVID值保持不变	

> Trunk端口的发送处理方法：
>
> - 对VID等于PVID的帧，“去标签”再转发
>
> Trunk端口接收处理方法：
>
> - 接收“未大标签”的帧，根据帧的端口的PVID给帧“打标签”，字段中的VID取值与端口的PVID取值相等



假设主机A发送一个广播帧，该帧从交换机1的端口进入交换机，由于端口1的类型为Access，对该帧打标签，并添加4自己的VID值，该广播帧中的VID的取值与端口2的PVID值都等于1，端口2的类型是Access，因此交换机1会从端口2对帧进行去标签转发

![image-20220703225733918](https://picture.xcye.xyz/image-20220703225733918.png)

该广播帧中的VID的取值与端口5的PVID值都等于1，端口5的类型是Trunk，因此交换机1会从端口5对帧进行“去标签转发”，并且该广播帧会从交换机2的端口5进入交换机2

![image-20220703225928512](https://picture.xcye.xyz/image-20220703225928512.png)

交换机2会对接收到的“未打标签”的普通以太网MAC帧“打标签”

![image-20220703230305416](https://picture.xcye.xyz/image-20220703230305416.png)

由于端口5的PVID值等于1，所以插入4字节的字段中的值也是1，该广播帧中的VID的取值与端口1和2的PVID值都等于1，并且1和2的端口都是Access，所以交换机2会从端口1和2对帧进行“去标签”转发

![image-20220703230506144](https://picture.xcye.xyz/image-20220703230506144.png)

![image-20220703230523569](https://picture.xcye.xyz/image-20220703230523569.png)

#### Hybrid

这个是华为交换机私有的端口类型

Hybrid端口既可用于交换机之间或交换机与路由器之间的互连（同Trunk端口），也可用户交换机与用户计算机之间的互连（同Access），其可以属于多个VLAN

![image-20220703230854610](https://picture.xcye.xyz/image-20220703230854610.png)

