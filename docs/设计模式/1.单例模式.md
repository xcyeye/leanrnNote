# 单例模式

> 单例模式(Singleton Design Pattern)：一个类`只允许创建一个对象（或者实例）`，那这个类就是一个单例类，这种设计模式叫做单例设计模式，简称`单例模式`

单例模式在哪些地方使用到：配置信息类，连接池类（比如应用只有一个MySQL连接），ID生成器类。



## 理解单例模式的唯一性

- 进程唯一单例：一个进程只能存在一个类的实例
- 线程唯一单例：一个线程中只能存在一个类的实例，线程存在于进程，一个进程中，可以存在多个该类实例

## 为什么要使用单例

> 单例模式能够避免资源访问冲突，表示业务概念上的全局唯一类

![image-20220721111156764](https://picture.xcye.xyz/image-20220721111156764.png)

对于上面的代码，如果是在一个单线程环境中时不会有问题的，但是如果是在多线程的环境中，就会出现问题，也就是同时有两个线程向同一个文件中写入message，那么就会存在日志信息被互相覆盖的情况

如果我们使用`synchroized`关键字在`log(String)`方法中加上`对象锁`，能解决问题么？答案是不能

![image-20220721111754622](https://picture.xcye.xyz/image-20220721111754622.png)

向上面这种，因为我们在两个controller中new了`Logger`对象，那么这里的this指向并不是同一个，也和没加`synchroized`是一样的，还有就是`FileWriter`本身就是一个线程安全的类，他的内部实现中本身就加了对象级别的锁

为了解决上面的问题，我们可以将对象所换成`类级锁`，让所有的对象都共享同一把锁

![image-20220721112120088](https://picture.xcye.xyz/image-20220721112120088.png)

> 上面这种是没有使用`单例模式`的写法，如果使用了单例模式之后，不同创建那么多Logger对象，一方面可以节省内存空间，另一方面可以节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）

![image-20220721112404745](https://picture.xcye.xyz/image-20220721112404745.png)

修改成上面的代码之后，我们不能通过`new Logger()`创建对象，因为构造方法是私有的，只能通过`getInstance()`方法获得Logger对象，这样我们就可以确保在多个类中使用同一个Logger对象，在加上FileWriter本身就是线程安全的，所以可以不用在加锁

`private static final Logger instance = new Logger()`这是是在编译器就已经把`new Logger()`这个实例放入常量池中



## 如何创建单例

1. 将所有的构造函数的访问权限修改为`private`，避免通过`new`关键字创建实例
2. 在创建的时候，考虑到创建时的线程安全问题
3. 考虑是否支持延迟加载(也就是这是对象是在程序启动时候就创建好还是使用到的时候在创建)
4. 考虑`getInstance()`方法的性能是否高（是否加锁）



### 饿汉式

![image-20220721114004577](https://picture.xcye.xyz/image-20220721114004577.png)

## 单例模式存在哪些问题？

1. 单例多OOP特性的支持不友好
2. 单例会隐藏类之间的依赖关系
3. 单例对代码的扩展性不友好
4. 单例对代码的可测试性不友好
5. 单例不支持有参数的构造函数



### 单例多OOP特性的支持不友好

```java
long id = IdGenerator.getInstance().getId();
```

比如对于上面这个，如果我们想要根据不同的需求返回不同的ID生成器，比如订单，用户使用不同的id生成器，那么最好的方法是使用接口，如果使用单例模式的话，就违背了基于接口，也就是OOP中的抽象性原则，到时候需要修改的地方很多



### 单例会隐藏类之间的依赖关系

这里说的依赖关系，指的是：比如我们创建一个对象，希望在`new`的时候，就可以通过构造方法中的参数看出这个对象需要哪些类的支持，也就是他们之间的依赖关系

以为单例模式不能new对象，而是通过`IdGenerator.getInstance()`，没有传参，所以看不出这个IdGenerator对象的依赖关系，只能通过点进这个类中，才能看到他们的依赖关系



### 单例对代码的扩展性不友好

单例模式影响扩展性是因为：单例模式的概念是一个进程中只能有一个类对象，但是如果有某种需求，需要有多个这个类的对象，那么到时候改起来的时候，很麻烦，从而影响了扩展性



### 单例对代码的可测试性不友好

![image-20220721132734045](https://picture.xcye.xyz/image-20220721132734045.png)

### 单例不支持有参数的构造函数

> 也就是我们希望通过传参的方式创建对象，比如MySQL的连接信息，但是`IdGenerator.getInstance().getId();`这种是不行的



#### 通过init()方法

![image-20220721133053413](https://picture.xcye.xyz/image-20220721133053413.png)

> 这种方法总结就是，使用前先通过传参初始化对象，程序启动之后，也只会创建一个对象，因为再次使用init()就会抛出异常



#### 参数放入getInstance()

![image-20220721133312451](https://picture.xcye.xyz/image-20220721133312451.png)

> 缺点：如果对象已经被创建了，那么以后使用`Singleton.getInstance()`的时候，也都需要传参，但是这些参数是没用的，不会使用这些参数初始化对象



### 参数放入另一个全局变量中

![image-20220721133446821](https://picture.xcye.xyz/image-20220721133446821.png)

这种方式相当于通过配置文件进行初始化

## 单例模式的替代解决方案

为了保证全局唯一性，除了使用单例，我们还可以使用静态方法来实现，不过静态方法这种实现思路并不能解决我们之前提到的问题，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。比如可以通过工厂模式，IOC容器(Spring IOC容器)来保证，也可以由程序员自己来保证

因为单例模式存在的问题，也有人把单例模式称为`反模式`，但是单例模式本身是没有错误的，如果在设计的时候，这个单例类并没有后续扩展的需求，并且不依赖外部系统，那么使用`单例模式`也没有问题



### 静态方法

如果不使用单例模式，但是又需要保证这个类对象是全局唯一的，那么可以使用静态方法

![image-20220721133602217](https://picture.xcye.xyz/image-20220721133602217.png)

> 缺点：灵活性差，不支持延迟加载



### 传递对象

![image-20220721133823438](https://picture.xcye.xyz/image-20220721133823438.png)

## 实现线程唯一的单例

可以通过HashMap来存储对象，比如ThreadLocal

![image-20220721134841513](https://picture.xcye.xyz/image-20220721134841513.png)

## 集群环境下的唯一性

一个集群中，会运行着多个同个程序，也就存在多个进程，要在这多个进程中实现类的唯一单例，可以在创建该对象的时候，将该对象序列化写入文件，存储在磁盘中，然后再使用，使用完成之后，还需要在存储会外部共享存储区中，为了保证在多线程环境下一次只能获得一个对象，就需要加锁处理，其实也可以使用redis



### 实现多例模式

多例指的是：一个类可以创建多个对象，但是个数是有限的（如只能创建3个对象）。

还有一种解释就是：同一类型只能创建一个对象，不同类型可以创建多个

![image-20220721135545390](https://picture.xcye.xyz/image-20220721135545390.png)